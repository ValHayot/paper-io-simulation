\documentclass[conference]{IEEEtran}

\begin{document}
\title{I/O simulation extension for SimGrid framework}
\author{Hoang-Dung Do}
\maketitle

	\begin{abstract}
		\begin{itemize}
			\item The I/O bottleneck in HPC and the need of experiments.
			\item HPC experiment frameworks and advantages of SimGrid.
			\item The missing of the ability to simulate page cache, the goal of this paper.
			\item Principle of the simulator, experiment scenarios and comparisons.
			\item Brief discussion on results and future work.
		\end{itemize}
	\end{abstract}

	\section{Introduction}
		\begin{itemize}
			\item HPC, the bottleneck in I/O and the demand of HPC experiments. 
			\item Difficulties in conducting high performance computing experiments and the need of simulation frameworks.
			\item Existing experiment methods, simulators, simulation frameworks. The advantages of SimGrid compared to others \cite{casanova2008, lebre2015}. The missing of the ability to simulate page cache in SimGrid \cite{lebre2015}.
			\item The objective of the paper: Add capability to simulate I/O with page cache in SimGrid.
		\end{itemize}
	\section{Related Work}			
		
		\subsection{Page cache}
			\begin{itemize}
				\item What is page cache? How it works \cite{linuxdev3rd2010}. Effects and importance of page cache.
				\item Introduce some existing strategies with some highlighted pros and cons.
				\item Current implementation in Linux and some reasons why it is chosen to be implemented (implementation complexity, effectiveness, overhead, etc) \cite{linuxdev3rd2010}
			\end{itemize}									

		\subsection{Simulators}
			\begin{itemize}
				\item Discuss some existing methods, simulation frameworks to conduct HPC experiments. Compare pros and cons (accuracy, simulation time, usability) of some simulators (SimGrid, GridSim).
				\item Related development: RAM energy consumption \cite{gill2019} \cite{ouarnoughi2017} 
				\item Discuss the pros of SimGrid and the reasons why we chose it to extend. (Section 2.2.2 in \cite{casanova2014})
			\end{itemize}
			
	\section{Method}
		In this section, we discuss our approach to model page cache and the cache eviction strategy implemented in Linux. We also detail the design the simulators in order to generalize page cache as well as the implementation in Python and SimGrid framework. Finally, we describe some experimental scenarios to compare the results of Python simulator, baseline SimGrid simulator and the results from the real pipelines.
		\subsection{Principle of the simulator}
	
			In order to make the simulator accurate, we try to simulate simulate page cache and mimic the 2-LRU lists cache eviction algorithm implemented in Linux. Our design also keeps track two LRU lists ans specific system configurations as in Linux kernel. However, maintaining and handling pages, which is in packet level, requires significant implementation overhead and hinders the performance of the simulator. To simplify the model whilst preserving accuracy, in our approach, we consider a sequence of continuously accessed pages of the same file from the same device as a single unit, a \textit{block} of data. The information of a single page in a sequence is representative for other pages the a sequence since they have the same properties including file name, last accessed, dirty or not. Thus, instead of dealing with individual pages, we view a sequence of continuously accessed pages as a block of data. A data block has the information about file name, size, last access and a dirty flag. As a block represents a set of pages in real systems, it can be split if some data needs to be moved between the LRU lists or evicted from cache, but blocks can not be merged as we want to preserve the access times of blocks to maintain the accuracy. 
			
			With this data block concept, when a file is accessed by an I/O operation, blocks are added to the top of inactive list if they are not existing in cache, or they are moved to the top of the list that they are kept in with last accesses updated. The lists are balanced after every time the simulator finishes reading or writing a portion of data from/to cache or disk.
			
			To simulate flushing and periodical flushing mechanisms, in which dirty data in cache is written to disk, we simply calculate the amount of flushed dirty data. Data flushing is called when the memory required by the application is more than available memory, while periodical flushing is called during CPU time. In flushing, the amount of dirty data to be flushed is calculated based on the amount of required memory, while the flushed amount in periodical flushing is estimated with CPU time. Initially, the blocks in inactive list are flushed first, and the next are dirty blocks in the active list, until the total flushed amount is reached. The flushed blocks are split if needed and become not dirty. The blocks in the inactive list which are not dirty are available for cache eviction. 
			
			Similar to flushing and periodical flushing, the amount of evicted data is calculated based on the the amount of memory required by application and the amount of free memory. Then, evicted blocks are deleted from inactive list, and the lists are balanced.
			
		\subsection{Implementation}
			\begin{itemize}
				\item Which features of memory are implemented.
				\item Level of granularity, how features are implemented.
				\item Specific implementation details in python and SimGrid.
			\end{itemize}

		\subsection{Experiments}
			For each experiment: 
			\begin{itemize}
				\item Describe data, workflow, number of tasks, task details, environment of each experiment.
				\item How we compare the results from real pipeline, baseline SimGrid  and SimGrid with our extension.
			\end{itemize}
	
			\subsubsection{Expriment 1}
				A single pipeline running one node.
			\subsubsection{Expriment 2}
				Multiple pipelines running in parallel on multiple nodes.
			\subsubsection{Expriment 3}
				Same as Experiment 2 but nodes write to a shared file system.
			\subsubsection{Expriment 4}
				A real pipeline (for example a pipeline with nighres)

	\section{Results}
	
		\begin{itemize}

			\item Quantitative results: 
				\begin{itemize}
					\item Errors of simulation time and memory used compared to real results.
					\item Simulation time compared to baseline SimGrid.
				\end{itemize} 

			\item Ability of the model to generalize memory trends (dirty data, cache used) and disk throughput.

		\end{itemize}

	\section{Discussion and Future Work}
		\begin{itemize}
			\item Sensitivity of the simulator on the variation of memory and disk bandwidth. 
		\end{itemize}
\bibliographystyle{plain}
\bibliography{citation}

\end{document}